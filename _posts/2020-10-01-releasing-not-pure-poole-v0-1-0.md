---
layout: post
title: 자바 컴파일 과정
author: zzangyeon
tags:
- java
date: 2020-10-01 13:56 +0800
---

<br/>

***자바는 OS에 독립적인 특징을 가지고 있다. 그게 가능한 이유는 JVM(Java Vitual Machine) 덕분이다. 그렇다면 JVM의 어떠한 기능 때문에, OS에 독립적으로 실행시킬 수 있는지 자바 컴파일 과정을 통해 알아보도록 하자.***

<br/>

![image](https://user-images.githubusercontent.com/79262461/127942742-fafd7fdb-9183-4c64-a3c4-b7e9f4a56649.png)

<br/>



<br/>

![image](https://user-images.githubusercontent.com/79262461/127942775-d55aa0ba-f2cf-43e7-9081-66adb9554415.png)


![image](https://user-images.githubusercontent.com/79262461/127942808-7921db2e-1f30-411d-ba93-8e76f646ec2c.png)

<br/>

## < 자바 컴파일 순서 >

<br/>

1. 개발자가 자바 소스코드(.java)를 작성한다.

2. 자바 컴파일러(Java Compiler)가 자바 소스파일을 컴파일한다.
이때 나오는 파일은 자바 바이트 코드(.class)파일로 아직 컴퓨터가 읽을 수 없는 자바 가상 머신이 이해할 수 있는 코드이다. 바이트 코드의 각 명령어는 1바이트 크기의 Opcode와 추가 피연산자로 이루어져 있다.

3. 컴파일된 바이트 코드를 JVM의 클래스로더(Class Loader)에게 전달.

4. 클래스 로더는 동적로딩(Dynamic Loading)을 통해 필요한 클래스들을 로딩 및 링크하여 런타임 데이터 영역(Runtime Data area), 즉 JVM의 메모리에 올린다.

    - 클래스 로더 세부 동작  
    a. 로드 : 클래스 파일을 가져와서 JVM의 메모리에 로드한다.  
    b. 검증 : 자바 언어 명세(Java Language Specification) 및 JVM 명세에 명시된 대로 구성되어 있는지 검사한다.  
    c. 준비 : 클래스가 필요로 하는 메모리를 할당(필드, 메서드, 인터페이스 등등)  
    d. 분석 : 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경한다.  
    e. 초기화 : 클래스 변수들은 적절한 값으로 초기화한다.(static 필드)

5. 실행엔진(Execution Engine)은 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행. 이때, 실행 엔진은 두가지 방식으로 변경한다.

    i. 인터프리터: 바이트 코드 명령어를 하나씩 읽어서 해석하고 실행한다. 하나하나의 실행은 빠르나, 전체적인 실행 속도가 느리다는 단점을 가짐.  

    ii. JIT 컴파일러(Just-In-Time Compiler) : 인터프리터의 단점을 보완하기 위해 도입된 방식으로 바이트 코드 전체를 컴파일하여 바이너리 코드로 변경하고 이후에는 해당 메서드를 더 이상 인터프리팅 하지 않고, 바이너리 코드로 직접 실행하는 방식이다. 하나씩 인터프리팅하여 실행하는 것이 아니라 바이트 코드 전체가 컴파일된 바이너리 코드를 실행하는 것이기 때문에 전체적인 실행속도는 인터프리팅 방식보다 빠름.

    <br/>

![image](https://user-images.githubusercontent.com/79262461/127942836-82ecba5d-6806-4bb1-94de-44c847c6b6c3.png)

<br/>

## < 자바 언어의 특징 >

<br/>

1. 운영체제에 독립적이다.
일종의 에뮬레이터인 자바가상머신(JVM)을 통해서 가능한 것인데, 자바 응용프로그램은 운영체제나 하드웨어가 아닌 JVM하고만 통신하고 JVM이 자바 응용프로그램으로부터 전달받은 명령을 해당 운영체제가 이해할 수 있도록 변환하여 전달한다.

2. 객체지향언어이다.
객체지향개념의 특징인 상속, 캡슐화, 다형성이 잘 적용된 순수한 객체지향 언어이다.

3. 비교적 배우기 쉽다.
자바의 연산자와 기본 구문은 C++에서, 객체지향관련 구문은 스몰톡(small talk)이라는 객체지향언어에서 가져왔다. 이 들 언어의 장점은 취하면서 복잡하고 불필요한 부분은 과감히 제거하여 단순화함으로서 쉽게 배울 수 있으며, 간결하고 이해하기 쉬운 코드를 작성할 수 있다.

4. 자동 메모리 관리(Garbage Collection)
자바로 작성된 프로그램이 실행되면, 가비지컬렉터(garbage collector)가 자동적으로 메모리를 관리해주기 때문에 프로그래머는 메모리를 따로 관리하지 않아도 된다.

5. 네트워크와 분산처리를 지원.
인터넷과 대규모 분산환경을 염두에 둔 까닭인지 풍부하고 다양한 네트워크 프로그래밍 라이브러리(Java API)를 통해 비교적 짧은 시간에 네트워크 관련 프로그램을 쉽게 개발할 수 있도록 지원.

6. 멀티쓰레드를 지원.
일반적으로 멀티쓰레드의 지원은 사용되는 운영체제에 따라 구현방법도 상이하며, 처리 방식도 다르다. 그러나 자바에서 개발되는 멀티쓰레드 프로그램은 시스템과는 관계없이 구현가능하며, 관련된 라이브러리(Java API)가 제공되므로 구현이 쉽다. 그리고 여러 쓰레드에 대한 스케줄링(scheduling)을 자바 인터프리터가 담당한다.

7. 동적 로딩(Dynamic Loading)을 지원한다.
보통 자바로 작성된 애플리케이션은 여러 개의 클래스로 구성되어 있다. 자바는 동적 로딩을 지원하기 때문에 실행 시에 모든 클래스가 로딩되지 않고 필요한 시점에 클래스를 로딩하여 사용할 수 있다는 장점이 있다. 그 외에도 일부 클래스가 변경되어도 전체 애플리케이션을 다시 컴파일하지 않아도 되며, 애플리케이션의 변경사항이 발생해도 비교적 적은 작업만으로도 처리할 수 있는 유여한 애플리케이션을 작성할 수 있다.

<br/>

---------------------------------------------------------------
> 자바의 단점으로는 속도문제가 가장 대표적인 것인데 바이트코드를   하드웨어의 기계어로 바로 변환해주는 JIT컴파일러와 Hotspot과 같은 기술의 도입으로 JVM의 기능이 향상됨으로써 속도문제가 상당히 개선되었다.

---------------------------------------------------------------

